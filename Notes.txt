Vertex and Fragment shaders are most popular
Another to consider Geometry shader 

Render PipeLine: Series of stages that take place in order to render an image on the screen
1. Vertex Specification
2. Vertex Shader (programmable)
3. Tessellation (programmable)
4. Geometry Shader (programmable)
5. Vertex Post-Processing
6. Primitive Assembly
7. Rasterization
8. Fragment Shader (programmable)
9. Per-Sample Operations

Verex: point in space usally defined x,y,z
Primitive: simple shape defined using one or more vertices. i.e triangle 3 points 
Vertex Specification: Setting up the data of the vertices for the primitives we want to render
	- Uses VAO (vertex array objects) and VBO (vertex buffer objects)
	- VAO defines what data vertex has (position, color, texture etc)
	- VBO defines the data itself
	- Attribute pointers define where and how shaders can access vertex data

	Creating VAO/VBO
	1. Generate a VAO ID
	2. Bind VAO with that ID
	3. Generate VBO ID
	4. Bind VBO with that ID (now you're working on chosen VBO attached to the chosen VAO)
	5. Attach the vertex data to that VBO
	6. Define the attribute pointer formatting 
	7. Enable the attribute pointer
	8. Unbind the VAO and VBO, ready for the next object to be bound

	Initating Draw
	1. Activate shader program you want to use
	2. Bind VAO of object you want to draw
	3. Call glDrawArrays, initating rest of pipeline

	Vertex Shader
	- Handles vertices individually
	- not optional, must define it 
	- must store something in gl_position as it used later
	- can specify additional outputs that can picked up and used by user defined shaders later
	- inputs consist of the vertex data itself
	Example:
	#version xxx i.e 330
	layout (location 0) in vec3 pos;
	void main(){
		gl_position = vec4(pos, 1.0)
	}

	Tessellation:
	- Allow you to divide up data into small primitives
	- Used to add high levels of detail dynamically, like oceans 

	Geometry Shader
	- Vertex shader handles vertices, geometry shader handles primitives (group of vertices)
	- Takes primitives then 'emits' their vertices to create the given primitive, or even new primitives
	- Can alter data given to it modify given primitives, or even create new onces
	- Can alter primtive type (pointes, lines, triangles etc)

	Vertex PostProcessing
	- Tranform Feedback (if enabled)
		- Result of vertex and Geometry stages saved to buffers for later use
	- Clipping
		- Primitives that wont be visible are removed (dont want to draw things we cant see)
		- Positions converted from clip-space to window space
		
	Primitive Assembly
	- Vertices are converted into series of primitives
	- Ex: If rendering triangles, 6 vertices would become 2 triangles
	- Face culling
		- Removal of primitives that cant be seen, or are facing away from the viewer

	Rasterization
	- Conerts primitives into 'fragments'
		- Pieces of data for each pixel, obtained from rasterization process
	- Fragment data will be interpolated based on its posiition relative to each vertex 

	Fragment Shader
	- Handles data for each fragment
	- Optional but its rare to not use it 
	- most important output is the color of pixel that the fragment covers 
	ex:
	#version xxx
	out vec4 color;
	void main(){
	color = vec4(1.0,0.0,0.0,1.0}; // rgb, alpha

	Per sample Operations
	- Series of test runs to see if the fragment should be drawn
	- Most important test: dpeth test. Determines if something is in front of the point being drawn
	- Color belnding: Using defined operations, fragment colors are 'blended' together with overlapping fragments. Usually used to handle transparent objects
	- Fragment data written to cuirrently bound frame buffer (usually default buffer)
	- Usually user defined buffer swap here, putting new updated framebuffer to the front

	Shaders
	- Shader programs are a group of shaders (vertex, tesselation, geometry, fragment ...) associated with one another

	Creating Shader Program
	1. Create empty program
	2. Create empty shaders
	3. Attach shader source code to shaders
	4. Compile shaders
	5. Attach shaders to program
	6. Link program (Create exes from shaders and link together)
	7. Validate program

	Using shader program
	- When you create a shader, ID is given (like with VAOs/VBOs)
	- Call glUseProgram(shaderID)
	- All draw calls from then on will use that shader. use it with 0 for no shader (switching it off)

	Summary:
	- Rendering pipeline consist of several stages
	- four stages are programmable via shaders (vertex, tessellation, geometry, fragment)
	- vertex shader is mandatory
	- vertices: user defined points in space
	- primitives: groups of vertices that make a simple shape (usually a triangle)
	- fragments: per-pixel data created from primitives
	- vertex array object (VAO): what data a vertex has
	- vertex buffer object (VBO): vertex data itself
	- Shader programs are created with at least a vertex shader and then activated before use